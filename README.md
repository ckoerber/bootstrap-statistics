# bootstrap-statistics
This repository contains a Python wrapper for a C++ routine which computes bootstrap distributions of the mean for randomly distributed variables.

## Content
[Description](#Description)
	1. [General idea](#General-idea)
2. [Getting started](#Getting-started)
    1. [Perquisites](#Perquisites)
    2. [Installing](#Installing)
    3. [Running the tests](#Running-the-tests)
3. [Usage](#Usage)
4. [Authors](#Authors)
5. [License](#License)

## <a name="Description"></a>Description
The objective of this module to estimate mean values of random variables including the uncertainty of the estimation.
This is specifically relevant, e.g., for variables generated by Hybrid Monte Carlo (HMC) integration algorithms.
For more details, I refer to https://arxiv.org/abs/hep-lat/0506036.

### <a name="General-idea"></a>General Idea

Assume the random variables are stored in an array `data` of shape `NVars x NConfigurations`.
We would like to estimate the mean value for each variable along the configuration axis.

The algorithm first averages over the configuration axis and creates bins of size `NBinSize`
```python
binnedData[nVar, nBin] = mean(data[nVar, nBin*NBinSize : (nBin+1)*NBinSize])
```
In case the number of configurations is not divisible by the bin size, the remaining configurations are thrown away at the beginning of the array. This can have two potential advantages:
It reduces the array size and thus speeds up computations,
It has the potential to remove autocorrelation within the data.

Next, the routine computes uniformly distributed indices in the interval from `0 .. NBins` of shape `NSamples x NSize` with possible repetitions.
The integer `NSize` is an input for the routine.
It is usually equal to the number of bins `NSize = NBins` -- it should not be too small but also not too large (to not allow too many redraws).

Finally, the routine computes the bootstrap samples of the mean according to
```python
samples = mean(binnedData[:, indices], axis=2)
```

Note that the code presented above is implented using C++ standard library routines. This optimizes performance and memory usage (performance boost of factor four compared to bumpy — see the examples).
Furthermore, all essential routine calls have unittests.

## <a name="Getting-started"></a>Getting started

### <a name="Perquisites"></a>Perquisites

Python Modules:
 - `numpy`
 - `cython`
 - `h5py`

While `numpy` and  `h5py` will be automatically installed when pip-installing the package, one has to pip install `cython` by hand (`setup.py` depends on `cython`).

Also, a standard 14 (`-std=c++14`) compatible C++ compiler is required.

### <a name="Installing"></a>Installing

This module can be pip installed by running
```bash
pip install -e .
```
This installation tracks updates of the repository (symlinks).
In case you do not want the tracking of updates but still have a pip install, just run
```bash
pip install .
```

For the basic compilation run 
```bash
make build
```
For this installation, you have to export or copy the resulting `.so` file to the directory in which you would like to run the scripts.

To see if the C++ files compile as desired, run
```bash
make cTest
```

The installation using all these commands assumes that your basic compiler is compatible with the `c++14` standard.
If this is not the case export a compatible compiler beforehand, e.g., by running
```bash
export CC=clang; export CXX=clang++; pip install -e .
```

To figure out if your compiler fulfills this standard, try to compile the C++ base files in `bootstats/cFiles`.

### <a name="Uninstalling"></a>Uninstalling
In case of a pip install, run
```bash
pip uninstall bootstrap-statistics
```

In case of `make build` install, run
```bash
make clean
```


### <a name="Running-the-tests"></a>Running the tests
You execute the unittests through `setup.py` by running
```bash
python3 setup.py test
```
Alternatively, you can execute the unittests through pythons `unittest` module
```bash
python -m -v "unittest" tests/testBootstats.py
```

Make sure that the python version matches the installation version.


## <a name="Usage"></a>Usage

The `Bootstrapper` class can be initialized with real and complex data.
On initialization, the random indices will be created.
The bootstrap samples can be accessed through the `samples` member of the class.
The computation of the samples is executed only once the first time the member is accessed.
It is not really important which dimension `nd > 2` the `data` array has as long as the last entry corresponds to the random entries of the variable.
In case this does not math you convention, you can use numpys `numpy.transpose` method.

Last but not least, the bootstrap indices (and also the samples) can be exported to `HDF5` files.
If done so, they can be read from `HDF5` files as well.

### Importing the basic module
```python
import bootstats
```

### Creating a Bootstrapper instance
Creation by parameters
```Python
data = np.random.random(size=[128, 1000])
bs1  = bootstats.Bootstrapper(data, NSamples=2000, NBinSize=5, NSize=200)
bs1.samples.shape # = 128 x 2000
```

Creation by indices
```Python
bs2 = bootstats.Bootstrapper(data, bs1.indices, NBinSize=5)
bs1 == bs2 # = True
```

Creation by HDF5 file
```Python
h5Info={"fileName": "test.h5", "groupName": "testGroup"}
bs1.exportHDF5(**h5Info)
bs3 = boot.Bootstrapper(data, h5Info=h5Info)
bs1 == bs3 # = True
```

For more example see the `examples/` directory.

## <a name="Authors"></a>Authors
* **Christopher Körber**


## <a name="License"></a>License

This project is licensed under the MIT License - see the [LICENSE.md](LICENSE.md) file for details

